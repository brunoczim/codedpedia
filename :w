use std::{
    error::Error,
    fmt::{self, Write},
};
use url::Url;

pub trait CompleteLocation: Clone + fmt::Debug + Eq {
    type ParseError: Error;

    fn parse(input: &str) -> Result<Self, Self::ParseError>;

    fn into_location(self) -> Location;

    fn eq_with_ctx(&self, location: &Location, page_path: &PagePath) -> bool;

    fn render_raw<W>(&self, page_path: &Path, writer: &mut W) -> fmt::Result
    where
        W: Write;
}

pub trait Borrow<'this, B> {
    fn borrow(&'this self) -> B;
}

pub trait Own {
    type Owned;

    fn own(self) -> Self::Owned;
}

#[derive(Debug, Clone)]
pub enum Location<P = Path, I = Id> {
    Internal(Internal<P, I>),
    External(Url),
}

pub type BorrowedLocation<'path, 'id> =
    Location<BorrowedPath<'path>, BorrowedId<'id>>;

pub type BorrowedLocationFragments<'path, 'fragment, 'id> =
    Location<BorrowedPathFragments<'path, 'fragment>, BorrowedId<'id>>;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Internal<P = Path, I = Id> {
    Path(P),
    Id(I),
    PathWithId(P, I),
}

pub type BorrowedInternal<'path, 'id> =
    Internal<BorrowedPath<'path>, BorrowedId<'id>>;

pub type BorrowedInternalFragments<'path, 'fragment, 'id> =
    Internal<BorrowedPathFragments<'path, 'fragment>, BorrowedId<'id>>;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Path<F = Vec<Fragment>> {
    pub fragments: F,
}

pub type BorrowedPath<'fragments, F = Fragment> = Path<&'fragments [F]>;

pub type BorrowedPathFragments<'fragments, 'fragmment> =
    BorrowedPath<'fragments, BorrowedFragment<'fragmment>>;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Fragment<S = Box<str>> {
    contents: S,
}

pub type BorrowedFragment<'contents> = Fragment<&'contents str>;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Id<S = Box<str>> {
    contents: S,
}

pub type BorrowedId<'contents> = Id<&'contents str>;

impl<'this> Borrow<'this, BorrowedId<'this>> for Id {
    fn borrow(&'this self) -> BorrowedId<'this> {
        Id { contents: &self.contents[..] }
    }
}

impl<S> Own for Id<S>
where
    S: Into<Box<str>>,
{
    type Owned = Id;

    fn own(self) -> Self::Owned {
        Id { contents: self.contents.into() }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InvalidPath {
    InvalidFragment(InvalidFragment),
}

impl From<InvalidFragment> for InvalidPath {
    fn from(error: InvalidFragment) -> Self {
        Self::InvalidFragment(error)
    }
}

impl fmt::Display for InvalidPath {
    fn fmt(&self, fmtr: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::InvalidFragment(error) => fmt::Display::fmt(error, fmtr),
        }
    }
}

impl Error for InvalidPath {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::InvalidFragment(error) => Some(error),
        }
    }
}

impl Path {
    pub const ROOT: Self = Self { fragments: Vec::new() };
}

impl CompleteLocation for Path {
    type ParseError = InvalidPath;

    fn parse(input: &str) -> Result<Self, Self::ParseError> {
        let mut this = Self::ROOT;

        if !input.is_empty() {
            for fragment_str in input.split('/') {
                this.fragments.push(Fragment::parse(fragment_str)?);
            }
        }

        Ok(this)
    }

    fn into_location(self) -> Location {
        Location::Internal(Internal::Path(self))
    }

    fn render_raw<W>(&self, page_path: &Path, writer: &mut W) -> fmt::Result
    where
        W: Write,
    {
        todo!()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InvalidFragment {
    Empty,
    CurrentDir,
    ParentDir,
    Bar,
    Hash,
}

impl fmt::Display for InvalidFragment {
    fn fmt(&self, fmtr: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Empty => write!(fmtr, "Fragment cannot be empty"),
            Self::CurrentDir => {
                write!(fmtr, "Fraagment cannot reference current directory")
            },
            Self::ParentDir => {
                write!(fmtr, "Fragment cannot reference parent directory")
            },
            Self::Bar => write!(fmtr, "Fragment cannot contain a bar '/'"),
            Self::Hash => write!(fmtr, "Fragment cannot contain a hash '#'"),
        }
    }
}

impl Error for InvalidFragment {}

impl CompleteLocation for Fragment {
    type ParseError = InvalidFragment;

    fn parse(input: &str) -> Result<Self, Self::ParseError> {
        if input.is_empty() {
            Err(InvalidFragment::Empty)?;
        }
        if input == "." {
            Err(InvalidFragment::CurrentDir)?;
        }
        if input == ".." {
            Err(InvalidFragment::ParentDir)?;
        }

        for ch in input.chars() {
            if ch == '/' {
                Err(InvalidFragment::Bar)?;
            }
            if ch == '#' {
                Err(InvalidFragment::Hash)?;
            }
        }

        Ok(Self { contents: input.into() })
    }

    fn into_location(self) -> Location {
        Location::Internal(Internal::Path(Path { fragments: vec![self] }))
    }

    fn render_raw<W>(&self, page_path: &Path, writer: &mut W) -> fmt::Result
    where
        W: Write,
    {
        if let Some(first) = page_path.fragments.first() {
            if first == self {
                for _ in 1 .. page_path.fragments.len() {
                    write!(writer, "../")?;
                }
            } else {
                for _ in 0 .. page_path.fragments.len() {
                    write!(writer, "../")?;
                }
                write!(writer, "{}", self.contents)?;
            }
        } else {
            write!(writer, "{}", self.contents)?;
        }

        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InvalidId {
    Empty,
    InvalidStart(char),
    InvalidChar(char),
}

impl fmt::Display for InvalidId {
    fn fmt(&self, fmtr: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Empty => write!(fmtr, "Id cannot be empty"),
            Self::InvalidStart(ch) => write!(
                fmtr,
                "Id must start with an ASCII letter, found {:?}",
                ch
            ),
            Self::InvalidChar(ch) => write!(
                fmtr,
                "Id must contain only ASCII letters, digits, '_' or '-', \
                 found {:?}",
                ch
            ),
        }
    }
}

impl Error for InvalidId {}

impl CompleteLocation for Id {
    type ParseError = InvalidId;

    fn parse(input: &str) -> Result<Self, Self::ParseError> {
        let mut iter = input.chars();

        let ch = iter.next().ok_or(InvalidId::Empty)?;
        if !ch.is_ascii_alphabetic() {
            Err(InvalidId::InvalidStart(ch))?;
        }

        for ch in iter {
            if !ch.is_ascii_alphanumeric() && ch != '_' && ch != '-' {
                Err(InvalidId::InvalidChar(ch))?;
            }
        }

        Ok(Self { contents: input.into() })
    }

    fn into_location(self) -> Location {
        Location::Internal(Internal::Id(self))
    }

    fn eq_with_ctx(&self, location: &Location, page_path: &PagePath) -> bool {
        match location {
            Location::External(_) => false,
            Location::Internal(Internal::Path(_)) => false,
            Location::Internal(Internal::Id(id)) => id == self,
            Location::Internal(Internal::PathWithId(path, id)) => {
                id == self && path.eq_with_ctx(page_path, page_path)
            },
        }
    }

    fn render_raw<W>(&self, _page_path: &Path, writer: &mut W) -> fmt::Result
    where
        W: Write,
    {
        write!(writer, "#{}", self.contents)
    }
}
